#include "RTLib.cginc"
#include "Surfel.cginc"

// texture to store raytracing result
RWTexture2D<float4> _DxrTarget;
TextureCube _SkyBox;

float3 _CameraPosition;
float4 _CameraRotation;
float3 _CameraOffset;

int _FrameIndex;
int _SPP, _RPS;

#pragma max_recursion_depth 1 // system maximum according to Unity, isn't mentioned on the docs tho
// https://docs.unity3d.com/2023.1/Documentation/ScriptReference/Experimental.Rendering.RayTracingShader-maxRecursionDepth.html
// must not be surpassed, or Unity will crash (why? 😟)

[shader("raygeneration")]
void PixelGI() {
	// start one ray per pixel

	// current pixel
	uint2 dispatchIdx = DispatchRaysIndex().xy;
	// target resolution
	uint2 launchDim = DispatchRaysDimensions().xy;
	
	// init random seed from current pixel location and frame index
	uint seed = initRand(dispatchIdx.x + dispatchIdx.y * launchDim.x, _FrameIndex);

	// get random uv inside current pixel
	// this gives us anti-aliasing for free
	// + float2(nextRand(seed), nextRand(seed))
	float3 rayDir = normalize(quatRot(float3((float2)dispatchIdx - _CameraOffset.xy, _CameraOffset.z), _CameraRotation));

	RayDesc rayDesc;
	RayPayload rayPayload;
	rayPayload.randomSeed = seed;
	rayPayload.withinGlassDepth = 0;

	float3 color = 0;
	int samplesPerPixel = _SPP; // per frame
	int raysPerSample = _RPS;
	for(int j=0;j<samplesPerPixel;j++){

		// init ray decriptor
		rayDesc.Origin = _CameraPosition;
		rayDesc.Direction = rayDir;

		// Create and init the ray payload
		rayPayload.color = float3(1,1,1);

		bool foundLight = false;
		for(int i=0;i<raysPerSample;i++) {

			rayDesc.TMin = 0.001;
			rayDesc.TMax = 1000;
			rayPayload.depth = i;

			// shoot primary ray
			// flags: https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html
			// maybe for later, for shadows: RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH
			TraceRay(_RaytracingAccelerationStructure,
				rayPayload.withinGlassDepth > 0 ? RAY_FLAG_NONE : RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
				RAYTRACING_OPAQUE_FLAG, 0, 1, 0, rayDesc, rayPayload);

			// evaluate result
			float3 n = rayPayload.dir;
			if(dot2(n) > 0.0 && dot2(rayPayload.color) > 0) {
				// continue tracing
				rayDesc.Origin = rayPayload.pos;
				rayDesc.Direction = n;
			} else {
				// reached sky / emissive
				foundLight = true;
				break;
			}

		}

		if(foundLight) {
			color += rayPayload.color;
		}

	}

	// store result
	_DxrTarget[dispatchIdx] = float4(color, samplesPerPixel);	
}

SamplerState _LinearClamp;
// miss shader, used when we don't hit any geometry
[shader("miss")]
void PixelGIMiss(inout RayPayload rayPayload : SV_RayPayload) {
	// todo this looks like SDR... how do we get HDR colors?
	if(rayPayload.depth > 0) {
		float3 color = _SkyBox.SampleLevel(_LinearClamp, WorldRayDirection(), 0).rgb;
		rayPayload.color *= color;
	}
	rayPayload.dir = 0;
}
