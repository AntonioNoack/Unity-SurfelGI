#include "Common.cginc"


// todo compute surfel distribution:
// todo delete surfels, which are too large or too small
// todo create new surfels, where they are missing

// todo use resulting positions in SurfelShader.shader
// like https://forum.unity.com/threads/accessing-a-computebuffer-from-a-surface-shader-after-a-computeshader-writes-to-it-solved.497958/


// RWTexture2D<float4> _DxrTarget;

float3 _CameraPosition;
float4 _CameraRotation;
float3 _CameraOffset;

int _FrameIndex;

#pragma max_recursion_depth 8

 // rotate vector v using quaternion q
float3 quatRot(float3 v, float4 q) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

[shader("raygeneration")]
void RaygenShader() {
	// start one ray per pixel

	// current pixel
	uint2 dispatchIdx = DispatchRaysIndex().xy;
	// target resolution
	uint2 launchDim = DispatchRaysDimensions().xy;
	
	// init random seed from current pixel location and frame index
	uint seed = initRand(dispatchIdx.x + dispatchIdx.y * launchDim.x, _FrameIndex);

	// get random uv inside current pixel
	// this gives us anti-aliasing for free
	// + float2(nextRand(seed), nextRand(seed))
	float3 rayDir = normalize(quatRot(float3((float2)dispatchIdx - _CameraOffset.xy, _CameraOffset.z), _CameraRotation));

	// init ray decriptor
	RayDesc rayDesc;
	rayDesc.Origin = _CameraPosition;
	rayDesc.Direction = rayDir;
	rayDesc.TMin = 0;
	rayDesc.TMax = 100;

	// Create and init the ray payload
	RayPayload rayPayload;
	rayPayload.color = float3(0.0, 0.0, 0.0);
	rayPayload.randomSeed = seed;
	rayPayload.depth = 0;

	// shoot primary ray
	// flags: https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html
	// maybe for later, for shadows: RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH
	TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
		RAYTRACING_OPAQUE_FLAG, 0, 1, 0, rayDesc, rayPayload);

	// store result
	// _DxrTarget[dispatchIdx] = float4(rayPayload.color, 1);	
}

// "back up" closest hit shader. it is used when we hit material without raytracing shader pass
[shader("closesthit")]
void ClosestHitMain(inout RayPayload rayPayload : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes) {}

// miss shader, used when we don't hit any geometry
[shader("miss")]
void MissShader(inout RayPayload rayPayload : SV_RayPayload) {}
