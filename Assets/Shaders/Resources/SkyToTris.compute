#pragma kernel SkyToTris

#include "Common.cginc"
#include "Surfel.cginc"

uint3 _DispatchOffset;

RWStructuredBuffer<Triangle> _Triangles;

uint _NumTris;
float _InvSunSize;

// todo update the sky color on the sky mesh
// todo use the cubemap
// todo keep the weights (?)

float2 _SkySunRatio;
float3 _SunDir;

float samplingDensity(float3 v) {

    float skyDensity = 1.0;// mostly contant, probably slightly less at the bottom
    float x = dot(_SunDir, v);

    // this is an integral over a linear section, which is technically incorrect;
    // however, this is a guess, and a sampling density only, so
    // it doesn't have that much of an effect

    // correct form: integrate (angleToSunCenter < sunRadiusOnSky ? 1 : 0) * acos(x)
    // assuming the sun is a constant-colored disk

    float sunIntegral = 0.5 * _InvSunSize;
    float sunDensity = max(1.0 - (1.0-x) / _InvSunSize, 0.0) / sunIntegral;// sharp around the sun, depending on _ClearSky

    // return "good" density: monotone for cloudy sky (except for floor maybe), strong for sunny, clear sky
    // total sum doesn't matter too much, as long as we know it, and adjust for it as a sky vs scene light brightness
    return dot(_SkySunRatio, float2(skyDensity, sunDensity));

}

TextureCube _SkyBox;
SamplerState _LinearClamp;

[numthreads(256,1,1)]
void SkyToTris(uint3 dispatchIdx : SV_DispatchThreadID) {
    uint index = dispatchIdx.x + _DispatchOffset.x;
    if(index < _NumTris) {

        Triangle tri = _Triangles[index];
        float3 a = float3(tri.ax,tri.ay,tri.az);
        float3 b = float3(tri.bx,tri.by,tri.bz);
        float3 c = float3(tri.cx,tri.cy,tri.cz);

        // todo calculate lod

        // more samples?
        float3 color = 
            _SkyBox.SampleLevel(_LinearClamp, a, 0).rgb +
            _SkyBox.SampleLevel(_LinearClamp, b, 0).rgb +
            _SkyBox.SampleLevel(_LinearClamp, c, 0).rgb +
            _SkyBox.SampleLevel(_LinearClamp, (a+b+c), 0).rgb;

        color /= 4.0 * samplingDensity(normalize(a+b+c));

        tri.r = color.x;
        tri.g = color.y;
        tri.b = color.z;

        _Triangles[index] = tri;

    }
}
