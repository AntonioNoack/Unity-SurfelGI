#pragma max_recursion_depth 31 // system maximum according to Unity, isn't mentioned on the docs tho
// https://docs.unity3d.com/2023.1/Documentation/ScriptReference/Experimental.Rendering.RayTracingShader-maxRecursionDepth.html
// must not be surpassed, or Unity will crash (why? ðŸ˜Ÿ)

#include "RTLib.cginc"
#include "Surfel.cginc"

uint _FrameIndex;
float _LightAccuArea;

RWStructuredBuffer<Triangle>    g_Triangles;
RWStructuredBuffer<LightSample> g_Samples;

[shader("miss")]
void LS1MissShader(inout RayPayload rayPayload : SV_RayPayload) {
    rayPayload.weight = 0;
}

[shader("raygeneration")]
void TestPass1() {

#include "SampleTri.cginc"

    // trace rayDesc into scene, and collect probabilty (weight) + color + where we landed
    RayDesc rayDesc;
    rayDesc.Origin = rayOrigin;
    rayDesc.Direction = rayDirection;
    rayDesc.TMin = 0.01;
    rayDesc.TMax = 1000;
    
    RayPayload rayPayload = (RayPayload) 0;
    rayPayload.color = float3(tri.r,tri.g,tri.b);
    rayPayload.weight = 1;
    rayPayload.pos = rayDesc.Origin;
    rayPayload.dir = rayDesc.Direction;
    rayPayload.withinGlassDepth = 0;
    
    int raysPerSample = 5;
    bool foundLight = true;
    for(int i=0;i<raysPerSample;i++){
        
        rayPayload.depth = i;

        TraceRay(_RaytracingAccelerationStructure,
				rayPayload.withinGlassDepth > 0 ? RAY_FLAG_NONE : RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
				RAYTRACING_OPAQUE_FLAG, 0, 1, 0, rayDesc, rayPayload);

        if(dot2(rayPayload.color) == 0.0 || dot2(rayPayload.dir) == 0.0 || rayPayload.weight == 0.0){
            foundLight = false;
            break;
        } else if(rayPayload.depth == 0xffff){
            // found a surface to land on
            break;
        } else {
            rayDesc.Origin = rayPayload.pos;
            rayDesc.Direction = rayPayload.dir;
        }

    }

    // then save our findings into the temporary array for the second part
    LightSample result;
    result.color = foundLight ? rayPayload.color : float3(0,0,0);
    result.weight = rayPayload.weight;
    result.surfacePos = rayPayload.pos;
    result.surfaceDir = rayPayload.dir;// todo we need a secondary property for this
    g_Samples[index] = result;
    
}
