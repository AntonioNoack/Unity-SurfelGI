#pragma max_recursion_depth 1

#include "Common.cginc"
#include "Surfel.cginc"

// Input
RaytracingAccelerationStructure g_SceneAccelStruct, rtas2;
float4x4                        g_InvViewMatrix;
float4x4                        g_ViewMatrix;
float                           g_Zoom;
float                           g_Blit;

// Output
RWTexture2D<float4>             g_Output;
RWStructuredBuffer<Surfel>      g_Surfels;
RWStructuredBuffer<Triangle>    g_Triangles;

[shader("miss")]
void MainMissShader0(inout RayPayload payload : SV_RayPayload) {
    payload.color = float3(0, 0, 0);
}

[shader("raygeneration")]
void MainRayGenShader() {

    // todo spawn ray from random triangle position

    uint2 LaunchIndex = DispatchRaysIndex().xy;
    uint2 LaunchDim = DispatchRaysDimensions().xy;

    float2 frameCoord = float2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1) + float2(0.5, 0.5);

    // The ray origin is the camera position in world space.
    float3 rayOrigin = float3(g_InvViewMatrix[0][3], g_InvViewMatrix[1][3], g_InvViewMatrix[2][3]);

    float2 ndcCoords = frameCoord / float2(LaunchDim.x - 1, LaunchDim.y - 1);
        
    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    float aspectRatio = (float)LaunchDim.x / (float)LaunchDim.y;

    float3 viewDirection = normalize(float3(ndcCoords.x * aspectRatio, ndcCoords.y, -1));

    // Rotate the ray from view space to world space.
    float3 rayDirection = normalize(mul((float3x3)g_InvViewMatrix, viewDirection));

	uint numTriangles, stride;
	g_Triangles.GetDimensions(numTriangles, stride);
    if(numTriangles > 0 && !g_Blit) { // this works for now, so I have good hopes to get it working :)
        int index = LaunchIndex.x + LaunchIndex.y * LaunchDim.x;
        uint randomSeed = initRand(LaunchIndex.x, LaunchIndex.y);
        Triangle tri = g_Triangles[index % numTriangles];
        float u = nextRand(randomSeed), v = nextRand(randomSeed);
        if(u > v) {
            u = 1-u;
            v = 1-v;
        }
        float3 triA = float3(tri.ax,tri.ay,tri.az), triB = float3(tri.bx,tri.by,tri.bz), triC = float3(tri.cx,tri.cy,tri.cz);
        rayDirection = normalize(normalize(cross(triB-triA, triC-triA)) + float3(nextRand(randomSeed),nextRand(randomSeed),nextRand(randomSeed))*2.0-1.0);
        rayOrigin = lerp(lerp(triA, triB, u), triC, v) + rayDirection * 0.1;
    }

    RayDesc ray;
    ray.Origin = rayOrigin;
    ray.Direction = rayDirection;
    ray.TMin = 0;
    ray.TMax = 1000;
        
    RayPayload payload = (RayPayload) 0;
    payload.color = float3(1, 0, 0);

    uint missShaderIndex = 0;
    TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload);

    if(payload.surfelId > 0){
        g_Surfels[payload.surfelId].color += float4(10,1,1,1);// red light for testing
    }

    if(g_Blit) g_Output[frameCoord] = float4(payload.color, 1);
}
