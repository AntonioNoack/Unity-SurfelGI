#include "RTLib.cginc"
#include "Surfel.cginc"

float3 _CameraPosition;
float4 _CameraRotation;
float3 _CameraOffset;
float2 _CameraUVSize;
float _Near;
float _Far;

int _FrameIndex;
int _SPP;
int _RPS;

#pragma max_recursion_depth 1 // system maximum according to Unity, isn't mentioned on the docs tho
// https://docs.unity3d.com/2023.1/Documentation/ScriptReference/Experimental.Rendering.RayTracingShader-maxRecursionDepth.html
// must not be surpassed, or Unity will crash (why? 😟)

RWStructuredBuffer<Surfel> _Surfels;

float3 TraceRay(RayDesc rayDesc, RayPayload rayPayload, int maxRaysPerSample, out float3 nextSurfacePos) {

	bool foundLight = false;
	bool foundSurface = true;

	rayPayload.withinGlassDepth = 0;
	rayPayload.color = float3(1,1,1);

	rayDesc.TMin = 0.001; // margin for refractive objects; could be set to 0, when back faces are being culled
	rayDesc.TMax = _Far;

	for(int i=rayPayload.depth;i<maxRaysPerSample;i++) {

		rayPayload.depth = i;

		rayPayload.distance = _Far;
		TraceRay(_RaytracingAccelerationStructure,
			rayPayload.withinGlassDepth > 0 ? RAY_FLAG_NONE : RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
			RAYTRACING_OPAQUE_FLAG, 0, 1, 0, rayDesc, rayPayload);

		if(i == 1) {
			nextSurfacePos = rayPayload.pos;
		}

		if(dot2(rayPayload.dir) > 0.0){
			// continue tracing
			rayDesc.Origin = rayPayload.pos;
			rayDesc.Direction = rayPayload.dir;
		} else {
			// reached sky or emissive
			foundLight = true;
			break;
		}
			
	}

	if(!foundLight) return float3(0,0,0);
	else return rayPayload.color;

}

// miss shader, used when we don't hit any geometry
TextureCube _SkyBox;
SamplerState _LinearClamp;
[shader("miss")]
void SurfelPTMiss(inout RayPayload rayPayload : SV_RayPayload) {
	// todo this looks like SDR... how do we get HDR colors?
	if(rayPayload.depth > 0){
		float3 color = _SkyBox.SampleLevel(_LinearClamp, WorldRayDirection(), 0).rgb;
		rayPayload.color *= color;
	}
	rayPayload.distance = _Far;
	rayPayload.dir = 0;
}


[shader("raygeneration")]
void SurfelPathTracing() {

	// start one ray per surfel

	// current surfel
	uint index = DispatchRaysIndex().x;
	uint numSurfels, stride;
	_Surfels.GetDimensions(numSurfels, stride);
	if(index >= numSurfels) return;

	// we know the surface, but we do not know the local BDRF ->
	// we need to trace the first ray, even if we know where it ends

	Surfel surfel = _Surfels[index];
	float surfelSize = surfel.position.w;
	if(surfelSize >= _Far * 0.5) return; // the sky has GI = 1, so no updates required

	float3 surfelPos = surfel.position.xyz;
	float4 surfelRotation = surfel.rotation;
	float3 worldDir = normalize(surfelPos - _CameraPosition);
	float3 worldNormal = quatRot(float3(0,1,0), surfel.rotation);
	float3 cameraDir = quatRotInv(worldDir, _CameraRotation);

	// only update surfels, which are in front of the camera
	float2 uvTolerance = 1.05; // close to edge should be traced as well
	if(!(cameraDir.z > 0.0 && all(abs(cameraDir.xy) < _CameraUVSize * uvTolerance) && 
		// test whether the surfel can be visible from the camera; the sky has no GBuffer information in Unity -> skip this test
		dot(worldDir, worldNormal) < 0.0)) return;
	
	// init ray decriptor
	RayDesc rayDesc;

	int samplesPerSurfel = _SPP;
	int maxRaysPerSample = _RPS;

	// Create and init the ray payload
	RayPayload rayPayload = (RayPayload) 0;
	rayPayload.surfelRotation = surfel.rotation;
	rayPayload.surfelSize = surfelSize;
	rayPayload.gpt = false;

	// init random seed from current pixel location and frame index
	uint srcSeed = initRand(index ^ _FrameIndex, _FrameIndex);

	float cosa, sina, distance;
	float3 ray1Pos, ray2Pos;
	GenerateGradientRays(
		surfelPos, surfelRotation, surfelSize, rayPayload.randomSeed,
		cosa, sina, distance, ray1Pos, ray2Pos
	);

	bool hasChanged = false;
	bool supportTransparency = true;
	for(int j=0;j<samplesPerSurfel;j++){

		// go back a step
		float startDist = 0.1 * surfelSize;
		rayDesc.Origin = surfelPos - startDist * worldDir;
		rayDesc.Direction = normalize(surfelPos - _CameraPosition);
		rayDesc.TMin = supportTransparency ? _Near : startDist * 0.5;
		rayDesc.TMax = supportTransparency ? _Far : startDist * 2.0;

		float3 nextSurfacePos, ignored;
		rayPayload.randomSeed = srcSeed;
		float3 color = TraceRay(rayDesc, rayPayload, maxRaysPerSample, nextSurfacePos);
		uint nextSeed = rayPayload.randomSeed;
		
		SetupGradientRayStart(rayDesc, ray1Pos, nextSurfacePos);
		rayDesc.TMin = _Near;
		if(supportTransparency) rayDesc.TMax = _Far;
		rayPayload.randomSeed = srcSeed;// gradients shall use same seed for similar path (for less noise)
		float3 colorPx = TraceRay(rayDesc, rayPayload, maxRaysPerSample, ignored).rgb;

		SetupGradientRayStart(rayDesc, ray2Pos, nextSurfacePos);
		rayDesc.TMin = _Near;
		if(supportTransparency) rayDesc.TMax = _Far;
		rayPayload.randomSeed = srcSeed;// gradients shall use same seed for similar path (for less noise)
		float3 colorPy = TraceRay(rayDesc, rayPayload, maxRaysPerSample, ignored).rgb;

		surfel.color += float4(color, 1.0);
		hasChanged = true;
			
		float3 gradient1 = (colorPx - color) / distance;
		float3 gradient2 = (colorPy - color) / distance;

		// reverse rotation
		float3 gradientDX = gradient1 * cosa + gradient2 * sina;
		float3 gradientDZ =-gradient1 * sina + gradient2 * cosa;

		surfel.colorDx += float4(gradientDX, 1.0);
		surfel.colorDz += float4(gradientDZ, 1.0);
		
		srcSeed = nextSeed;// seed for next iteration

	}
	if(hasChanged) {
		_Surfels[index] = surfel;
	}
}

// texture to store raytracing result
RWTexture2D<float4> _ColorTarget;
RWTexture2D<float4> _ColorDxTarget;
RWTexture2D<float4> _ColorDyTarget;

[shader("raygeneration")]
void PixelPathTracing() {

    // current pixel
	uint2 dispatchIdx = DispatchRaysIndex().xy;
	// target resolution
	uint2 launchDim = DispatchRaysDimensions().xy;
	
	// get random uv inside current pixel
	// this gives us anti-aliasing for free
	// + float2(nextRand(seed), nextRand(seed))
	float3 rayDir = normalize(quatRot(float3((float2)dispatchIdx - _CameraOffset.xy, _CameraOffset.z), _CameraRotation));

    // current surfel
    uint2 index = DispatchRaysIndex().xy;

    // we know the surface, but we do not know the local BDRF .
    // we need to trace the first ray, even if we know where it ends

    float3 surfelPos = _CameraPosition;

    RayPayload rayPayload = (RayPayload) 0;
	RayDesc rayDesc = (RayDesc) 0;

	// init random seed from current pixel location and frame index
    uint srcSeed = initRand(dispatchIdx.x + dispatchIdx.y * launchDim.x, _FrameIndex);

	int samplesPerSurfel = _SPP;
	int maxRaysPerSample = _RPS;

    float4 finalColor = float4(0,0,0,0);
    float4 finalColorDx = float4(0,0,0,0);
    float4 finalColorDy = float4(0,0,0,0);

    for (int j = 0; j < _SPP; j++) {

		// go back a step
		rayDesc.Origin = _CameraPosition;
		rayDesc.Direction = rayDir;
		rayDesc.TMin = _Near;
		rayDesc.TMax = _Far;

		float3 ignored;
		rayPayload.randomSeed = srcSeed;
		float3 color = TraceRay(rayDesc, rayPayload, maxRaysPerSample, ignored);
		uint nextSeed = rayPayload.randomSeed;
		nextRand(nextSeed); // just in case nothing was drawn
		
		/* +x ------------------------------------------------------ */
		rayDesc.Origin = _CameraPosition;
		rayDesc.Direction = normalize(quatRot(float3((float2)dispatchIdx + float2(1.0,0.0) - _CameraOffset.xy, _CameraOffset.z), _CameraRotation));
		rayDesc.TMin = _Near;
		rayDesc.TMax = _Far;

		rayPayload.randomSeed = srcSeed;// gradients shall use same seed for similar path (for less noise)
		float3 colorPx = TraceRay(rayDesc, rayPayload, maxRaysPerSample, ignored);

		/* -x ------------------------------------------------------ */
		rayDesc.Origin = _CameraPosition;
		rayDesc.Direction = normalize(quatRot(float3((float2)dispatchIdx - float2(1.0,0.0) - _CameraOffset.xy, _CameraOffset.z), _CameraRotation));
		rayDesc.TMin = _Near;
		rayDesc.TMax = _Far;

		rayPayload.randomSeed = srcSeed;// gradients shall use same seed for similar path (for less noise)
		float3 colorMx = TraceRay(rayDesc, rayPayload, maxRaysPerSample, ignored);

		/* +y ------------------------------------------------------ */
		rayDesc.Origin = _CameraPosition;
		rayDesc.Direction = normalize(quatRot(float3((float2)dispatchIdx + float2(0.0,1.0) - _CameraOffset.xy, _CameraOffset.z), _CameraRotation));
		rayDesc.TMin = _Near;
		rayDesc.TMax = _Far;

		rayPayload.randomSeed = srcSeed;// gradients shall use same seed for similar path (for less noise)
		float3 colorPy = TraceRay(rayDesc, rayPayload, maxRaysPerSample, ignored);

		/* -y ------------------------------------------------------ */
		rayDesc.Origin = _CameraPosition;
		rayDesc.Direction = normalize(quatRot(float3((float2)dispatchIdx - float2(0.0,1.0) - _CameraOffset.xy, _CameraOffset.z), _CameraRotation));
		rayDesc.TMin = _Near;
		rayDesc.TMax = _Far;

		rayPayload.randomSeed = srcSeed;// gradients shall use same seed for similar path (for less noise)
		float3 colorMy = TraceRay(rayDesc, rayPayload, maxRaysPerSample, ignored);

		/* write results ------------------------------------------- */
		finalColor += float4(color, 1.0);
		finalColorDx += float4((colorPx.xyz - colorMx.xyz) * 0.5, 1.0);
		finalColorDy += float4((colorPy.xyz - colorMy.xyz) * 0.5, 1.0);

		srcSeed = nextSeed;// seed for next iteration

    }

	// store result
	_ColorTarget[index] = finalColor;
	_ColorDxTarget[index] = finalColorDx;
	_ColorDyTarget[index] = finalColorDy;

}
