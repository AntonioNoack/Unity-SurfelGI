#include "RTLib.cginc"
#include "Surfel.cginc"

float3 _CameraPosition;
float4 _CameraRotation;
float2 _CameraUVSize;
float _Near;
float _Far;

int _FrameIndex;
int _SPP;
int _RPS;

#pragma max_recursion_depth 1 // system maximum according to Unity, isn't mentioned on the docs tho
// https://docs.unity3d.com/2023.1/Documentation/ScriptReference/Experimental.Rendering.RayTracingShader-maxRecursionDepth.html
// must not be surpassed, or Unity will crash (why? 😟)

RWStructuredBuffer<Surfel> _Surfels;

float3 TraceRay(RayDesc rayDesc, RayPayload rayPayload, int maxRaysPerSample) {

	bool foundLight = false;
	bool foundSurface = true;

	rayPayload.withinGlassDepth = 0;
	rayPayload.color = float3(1,1,1);

	rayDesc.TMin = 0.001; // margin for refractive objects; could be set to 0, when back faces are being culled
	rayDesc.TMax = _Far;

	for(int i=rayPayload.depth;i<maxRaysPerSample;i++) {

		rayPayload.depth = i;

		TraceRay(_RaytracingAccelerationStructure,
			rayPayload.withinGlassDepth > 0 ? RAY_FLAG_NONE : RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
			RAYTRACING_OPAQUE_FLAG, 0, 1, 0, rayDesc, rayPayload);

		if(dot2(rayPayload.dir) > 0.0){
			// continue tracing
			rayDesc.Origin = rayDesc.Origin + rayPayload.distance * rayDesc.Direction;
			rayDesc.Direction = rayPayload.dir;
		} else {
			// reached sky or emissive
			foundLight = true;
			break;
		}
			
	}

	if(!foundLight) return float3(0,0,0);
	else return rayPayload.color;

}

// miss shader, used when we don't hit any geometry
TextureCube _SkyBox;
SamplerState _LinearClamp;
[shader("miss")]
void SurfelPTMiss(inout RayPayload rayPayload : SV_RayPayload) {
	// todo this looks like SDR... how do we get HDR colors?
	if(rayPayload.depth > 0){
		float3 color = _SkyBox.SampleLevel(_LinearClamp, WorldRayDirection(), 0).rgb;
		rayPayload.color *= color;
	}
	rayPayload.distance = _Far;
	rayPayload.dir = 0;
}


[shader("raygeneration")]
void SurfelPathTracing() {

	// start one ray per surfel

	// current surfel
	uint index = DispatchRaysIndex().x;
	uint numSurfels, stride;
	_Surfels.GetDimensions(numSurfels, stride);
	if(index >= numSurfels) return;

	// we know the surface, but we do not know the local BDRF ->
	// we need to trace the first ray, even if we know where it ends

	Surfel surfel = _Surfels[index];
	float surfelSize = surfel.position.w;
	if(surfelSize >= _Far * 0.5) return; // the sky has GI = 1, so no updates required

	float3 surfelPos = surfel.position.xyz;
	float4 surfelRotation = surfel.rotation;
	float3 worldDir = normalize(surfelPos - _CameraPosition);
	float3 worldNormal = quatRot(float3(0,1,0), surfel.rotation);
	float3 cameraDir = quatRotInv(worldDir, _CameraRotation);

	// only update surfels, which are in front of the camera
	float2 uvTolerance = 1.05; // close to edge should be traced as well
	if(!(cameraDir.z > 0.0 && all(abs(cameraDir.xy) < _CameraUVSize * uvTolerance) && 
		// test whether the surfel can be visible from the camera; the sky has no GBuffer information in Unity -> skip this test
		dot(worldDir, worldNormal) < 0.0)) return;
	
	// init ray decriptor
	RayDesc rayDesc;

	int samplesPerSurfel = _SPP;
	int maxRaysPerSample = _RPS;

	// Create and init the ray payload
	RayPayload rayPayload = (RayPayload) 0;

	// init random seed from current pixel location and frame index
	rayPayload.randomSeed = initRand(index ^ _FrameIndex, _FrameIndex);

	bool supportTransparency = true;
	float3 color = float3(0,0,0);
	float startDist = 0.1 * surfelSize;
	rayDesc.TMin = supportTransparency ? _Near : startDist * 0.5;
	rayDesc.TMax = supportTransparency ? _Far : startDist * 2.0;
	for(int j=0;j<samplesPerSurfel;j++){

		// go back a step
		rayDesc.Origin = surfelPos - startDist * worldDir;
		rayDesc.Direction = normalize(surfelPos - _CameraPosition);

		color += TraceRay(rayDesc, rayPayload, maxRaysPerSample);
		
	}

	surfel.color += float4(color, samplesPerSurfel);
	_Surfels[index] = surfel;
	
}
