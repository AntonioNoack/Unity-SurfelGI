#include "RTLib.cginc"
#include "Surfel.cginc"

float3 _CameraPosition;
float4 _CameraRotation;
float3 _CameraOffset;
float2 _CameraUVSize;
float _Far;
bool _AllowStrayRays;

int _FrameIndex;

#pragma max_recursion_depth 2 // system maximum according to Unity, isn't mentioned on the docs tho
// https://docs.unity3d.com/2023.1/Documentation/ScriptReference/Experimental.Rendering.RayTracingShader-maxRecursionDepth.html
// must not be surpassed, or Unity will crash (why? 😟)

RWStructuredBuffer<Surfel> _Surfels;

float4 TraceRay(RayDesc rayDesc, RayPayload rayPayload, int maxRaysPerSample, out float3 nextSurfacePos) {

	bool foundLight = false;
	bool foundSurface = true;

	for(int i=rayPayload.depth;i<maxRaysPerSample;i++) {

		rayPayload.depth = i;

		if(i > 0) {
			rayDesc.TMin = 0.001; // margin for refractive objects; could be set to 0, when back faces are being culled
			rayDesc.TMax = _Far;
		}

		TraceRay(_RaytracingAccelerationStructure,
			rayPayload.withinGlassDepth > 0 ? RAY_FLAG_NONE : RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
			RAYTRACING_OPAQUE_FLAG, 0, 1, 0, rayDesc, rayPayload);

		if(i == 1) {
			nextSurfacePos = rayPayload.pos;
		}

		// if we land outside the expected region, reject the sample
		if(i == 0 && !(rayPayload.distance >= rayDesc.TMin && rayPayload.distance <= rayDesc.TMax)) {
			foundSurface = false;
			break;
		}

		float3 n = rayPayload.dir;
		if(dot2(n) > 0.0){
			// continue tracing
			rayDesc.Origin = rayPayload.pos;
			rayDesc.Direction = n;
		} else {
			// reached sky or emissive
			foundLight = true;
			break;
		}
			
	}

	if(foundSurface){
		if(!foundLight) rayPayload.color = 0;
		return float4(rayPayload.color, 1.0);
	} else return float4(0,0,0,0);

}

[shader("raygeneration")]
void SurfelPathTracing() {

	// start one ray per surfel

	// current surfel
	uint index = DispatchRaysIndex().x;
	uint numSurfels, stride;
	_Surfels.GetDimensions(numSurfels, stride);
	if(index >= numSurfels) return;

	// we know the surface, but we do not know the local BDRF ->
	// we need to trace the first ray, even if we know where it ends

	Surfel surfel = _Surfels[index];
	float surfelSize = surfel.position.w;
	if(surfelSize >= _Far * 0.5) return; // the sky has GI = 1, so no updates required

	float3 surfelPos = surfel.position.xyz;
	float4 surfelRotation = surfel.rotation;
	float3 worldDir = normalize(surfelPos - _CameraPosition);
	float3 worldNormal = quatRot(float3(0,1,0), surfel.rotation);
	float3 cameraDir = quatRotInv(worldDir, _CameraRotation);

	// only update surfels, which are in front of the camera
	float2 uvTolerance = 1.05; // close to edge should be traced as well
	if(!(cameraDir.z > 0.0 && all(abs(cameraDir.xy) < _CameraUVSize * uvTolerance) && 
		// test whether the surfel can be visible from the camera; the sky has no GBuffer information in Unity -> skip this test
		dot(worldDir, worldNormal) < 0.0)) return;

	// init random seed from current pixel location and frame index
	uint seed = initRand(index, _FrameIndex);
	
	// init ray decriptor
	RayDesc rayDesc;

	int samplesPerSurfel = 10;//max(1, 8 - (int) surfel.color.w);
	int maxRaysPerSample = 15;

	// Create and init the ray payload
	RayPayload rayPayload = (RayPayload) 0;
	rayPayload.surfelRotation = surfel.rotation;
	rayPayload.surfelSize = surfelSize;

	float cosa, sina, distance;
	float3 ray1Pos, ray2Pos;
	GenerateGradientRays(
		surfelPos, surfelRotation, surfelSize, rayPayload.randomSeed,
		cosa, sina, distance, ray1Pos, ray2Pos
	);

	bool hasChanged = false;
	for(int j=0;j<samplesPerSurfel;j++){

		// go back a step
		float startDist = 0.1 * surfelSize;
		rayDesc.Origin = surfelPos - startDist * worldDir;
		rayDesc.Direction = normalize(surfelPos - _CameraPosition);
		rayDesc.TMin = startDist * 0.5;
		rayDesc.TMax = startDist * 2.0;
		rayPayload.color = float3(1,1,1);
		rayPayload.depth = 0;
		rayPayload.distance = 0.0;
		rayPayload.randomSeed = seed;
		rayPayload.withinGlassDepth = 0;

		float3 nextSurfacePos, ignored;
		float4 color = TraceRay(rayDesc, rayPayload, maxRaysPerSample, nextSurfacePos);
		if(color.w <= 0.0) break; // try again; but we have no randomness until this point -> cancel
		
		rayPayload.color = float3(1,1,1);
		rayPayload.withinGlassDepth = 0;
		SetupGradientRayStart(rayDesc, ray1Pos, nextSurfacePos);

		float3 colorD1 = TraceRay(rayDesc, rayPayload, maxRaysPerSample, ignored).rgb;

		rayPayload.color = float3(1,1,1);
		rayPayload.withinGlassDepth = 0;
		SetupGradientRayStart(rayDesc, ray2Pos, nextSurfacePos);

		float3 colorD2 = TraceRay(rayDesc, rayPayload, maxRaysPerSample, ignored).rgb;


		surfel.color += color;
			
		float3 gradient1 = (colorD1 - color.xyz) / distance;
		float3 gradient2 = (colorD2 - color.xyz) / distance;

		// reverse rotation
		float3 gradientDX = gradient1 * cosa + gradient2 * sina;
		float3 gradientDZ =-gradient1 * sina + gradient2 * cosa;

		surfel.colorDx += float4(gradientDX, 1.0);
		surfel.colorDz += float4(gradientDZ, 1.0);
		hasChanged = true;

	}
	if(hasChanged) {
		_Surfels[index] = surfel;
	}
}

// miss shader, used when we don't hit any geometry
TextureCube _SkyBox;
SamplerState _LinearClamp;
[shader("miss")]
void SurfelPTMiss(inout RayPayload rayPayload : SV_RayPayload) {
	// todo this looks like SDR... how do we get HDR colors?
	if(rayPayload.depth > 0){
		float3 color = _SkyBox.SampleLevel(_LinearClamp, WorldRayDirection(), 0).rgb;
		rayPayload.color *= color;
	}
	rayPayload.distance = _Far;
	rayPayload.dir = 0;
}
