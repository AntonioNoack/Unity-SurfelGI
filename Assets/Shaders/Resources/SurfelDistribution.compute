
#pragma kernel SurfelDistribution

// todo compute surfel distribution:
// todo delete surfels, which are too large or too small
// todo create new surfels, where they are missing

// todo use resulting positions in SurfelShader.shader
// like https://forum.unity.com/threads/accessing-a-computebuffer-from-a-surface-shader-after-a-computeshader-writes-to-it-solved.497958/


struct Surfel {
    float4 rotation;
    float3 position;
    float size;
    float4 color;
};

#define PI 3.141592653589793

RWStructuredBuffer<Surfel> Surfels;

// todo theoretically, we need a matrix array, and a ptr to the matrix on every Surfel
RWStructuredBuffer<float4x4> Transforms;

// GBuffer and depth at camera
Texture2D<half4>  _CameraGBufferTexture0;
Texture2D<half4>  _CameraGBufferTexture1;
Texture2D<half4>  _CameraGBufferTexture2;
Texture2D<float> _CameraDepthTexture;
SamplerState _PointClampSampler;

/*UnityStandardData data;
data.diffuseColor   = inGBuffer0.rgb;
data.occlusion      = inGBuffer0.a;
data.specularColor  = inGBuffer1.rgb;
data.smoothness     = inGBuffer1.a;
data.normalWorld    = normalize((float3)inGBuffer2.rgb * 2 - 1);*/

float _Time;

float3 _CameraPosition;
float4 _CameraRotation;
float2 _CameraUVScale;

float4 _ZBufferParams;

// adopted from https://answers.unity.com/questions/467614/what-is-the-source-code-of-quaternionlookrotation.html
float4 normalToQuaternion(float3 normal){
    float3 v1 = normal; // m1x
    // float3 v0 = normalize(cross(normal, float3(0,1,0)));// could be simplified
    float3 v0 = dot(normal.xy,normal.xy) < 1.0 ? 
        normalize(float3(normal.z, 0, -normal.x)) : float3(1,0,0);// m0x; could be simplified when using the fib sphere
    float3 v2 = cross(v0,v1); // m2x
    float diag = v0.x + v1.y + v2.z;
    // we assume diag > 0, is correct for fib sphere
    float num = sqrt(diag + 1.0);
    return float4(float3(v1.z - v2.y, v2.x - v0.z, v0.y - v1.x) * (0.5 / num), num * 0.5);
}

// adopted from https://stackoverflow.com/a/26127012/4979303
float3 fibonacciSphere(int i, int n){
    const float phi = PI * (3.0 - sqrt(5.0));
    float i2 = float(i);
    float y = 1.0 - 2.0 * i2 / float(n-1);
    float theta = phi * i2;
    float radius = sqrt(max(1.0 - y * y, 0.0));
    return float3(cos(theta) * radius, y, sin(theta) * radius);
}

float3 quatRot(float3 v, float4 q){
	return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float3 quatRotInv(float3 v, float4 q){
	return v - 2.0 * cross(q.xyz, cross(v, q.xyz) + q.w * v);
}

float linear01Depth(float z){
	return 1.0 / (_ZBufferParams.x * z + _ZBufferParams.y);
}

float linearEyeDepth(float z){
	return 1.0 / (_ZBufferParams.z * z + _ZBufferParams.w);
}

[numthreads(64,1,1)]
void SurfelDistribution(uint3 dispatchIdx : SV_DispatchThreadID) {

    uint index = dispatchIdx.x;
    uint length = Surfels.Length;
    if(index < length){

        Surfel result;

        float3 worldDir = fibonacciSphere(index, length);
        float4 surfelRot = normalToQuaternion(worldDir);

        float far = 1000;

        // calculate UV coordinates on camera
        float3 cameraDir = quatRotInv(worldDir, _CameraRotation);
        float density = false ? 0.7 : 3.0;
        if(cameraDir.z > 0.0){ // else hidden & no update required

            cameraDir.xy *= _CameraUVScale;
            float2 uv = cameraDir.xy / cameraDir.z * 0.5 + 0.5;

            if(all(uv > float2(0,0)) && all(uv < float2(1,1))){ // else outside of view frustum

                float3 diffuse  = _CameraGBufferTexture0.SampleLevel(_PointClampSampler, uv, 0).rgb;
                float3 specular = _CameraGBufferTexture1.SampleLevel(_PointClampSampler, uv, 0).rgb;
                float3 color = diffuse + specular;

                // float depth = 1.0 / _CameraDepthTexture.SampleLevel(_PointClampSampler, uv, 0).r;
                float rawDepth = _CameraDepthTexture.SampleLevel(_PointClampSampler, uv, 0).r;
                if(rawDepth > 0.0){

                    float depth = linearEyeDepth(rawDepth) / cameraDir.z;
                
                    float radius = depth;
                    result.position = _CameraPosition + worldDir * radius;

                    float3 surfaceDir = normalize(_CameraGBufferTexture2.SampleLevel(_PointClampSampler, uv, 0).xyz*2.0-1.0);
                    result.rotation = normalToQuaternion(surfaceDir);
                    // surface area of a sphere: 4*pi*r²
                    float dt = max(-dot(worldDir, surfaceDir), 0.1);
                    result.size = density * 4.0 * radius / (sqrt(float(length) * dt));
                    // result.color = float4(uv,frac(depth),1);
                    result.color = float4(color,1.0);
                    // result.color = float4(dt,dt,dt,1);
                    // result.color = float4(max(worldDir,0),1);
                    // if(uv.x > 0.5) result.color = float4(max(surfaceDir, 0),1);
                    float fd = frac(log2(depth));
                    // result.color = float4(fd,depth>0.0?fd:0.0,depth>0.0?fd:0.0,1);

                    Surfels[index] = result;
                    return;

                }
                

            }
        }

        float radius = far * 0.5;
        result.position = _CameraPosition + worldDir * radius;

        result.rotation = surfelRot;
        // surface area of a sphere: 4*pi*r²
        result.size = density * 4.0 * radius / sqrt(float(length));
        // result.color = float4(abs(cameraDir),1);
        result.color = float4(1,1,1,1);

        Surfels[index] = result;

    }
}
