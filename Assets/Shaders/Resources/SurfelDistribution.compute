
#pragma kernel InitSurfelDistribution
#pragma kernel DiscardSmallAndLargeSurfels
#pragma kernel SpawnSurfelsInGaps

#include "Random.cginc"
#include "Surfel.cginc"
#include "Common.cginc"

#define PI 3.141592653589793

#define START_WEIGHT 0.0

RWStructuredBuffer<Surfel> Surfels;

// todo theoretically, we need a matrix array, and a ptr to the matrix on every Surfel
// RWStructuredBuffer<float4x4> Transforms;

// GBuffer and depth at camera
Texture2D<half4>  _CameraGBufferTexture0;
Texture2D<half4>  _CameraGBufferTexture1;
Texture2D<half4>  _CameraGBufferTexture2;
Texture2D<float> _CameraDepthTexture;
SamplerState _PointClampSampler;

/*UnityStandardData data;
data.diffuseColor   = inGBuffer0.rgb;
data.occlusion      = inGBuffer0.a;
data.specularColor  = inGBuffer1.rgb;
data.smoothness     = inGBuffer1.a;
data.normalWorld    = normalize((float3)inGBuffer2.rgb * 2 - 1);*/

float _Time;
float _Far;

float _Density;

int _FrameIndex;

float3 _CameraPosition;
float3 _CameraDirection;
float4 _CameraRotation;
float2 _CameraUVScale;

float3 _PrevCameraPosition;

float4 _ZBufferParams;

bool _AllowSkySurfels;

uint3 _DispatchOffset;

Texture2D<half4> _Weights;
float3 _CameraOffset;

bool _EnableSurfelMovement;

// adopted from https://stackoverflow.com/a/26127012/4979303
float3 fibonacciSphere(int i, int n){
    const float phi = PI * (3.0 - sqrt(5.0));
    float i2 = float(i);
    float y = 1.0 - 2.0 * i2 / float(n-1);
    float theta = phi * i2;
    float radius = sqrt(max(1.0 - y * y, 0.0));
    return float3(cos(theta) * radius, y, sin(theta) * radius);
}

float linear01Depth(float z) {
	return 1.0 / (_ZBufferParams.x * z + _ZBufferParams.y);
}

float linearEyeDepth(float z) {
	return 1.0 / (_ZBufferParams.z * z + _ZBufferParams.w);
}

float calculateSize(float distance, float dot) {
    return min(_Density * 4.0 * distance / (sqrt(float(Surfels.Length)) * (abs(dot)*.5+.5)), _Far * 0.5);
}

Surfel InitSkySurfel(float3 worldDir) {
    float distance = _Far * 0.5;
    Surfel surfel;
    surfel.position.xyz = _CameraPosition + worldDir * distance;
    surfel.rotation = 0;
    surfel.position = 0;
    if(_AllowSkySurfels){
        surfel.rotation = normalToQuaternion(worldDir);
        // surface area of a sphere: 4*pi*r²
        surfel.position.w = calculateSize(distance, 1.0);
    }
    surfel.color = 1;// sky has GI = 1
    surfel.colorDx = 0;
    surfel.colorDz = 0;
    surfel.data = 0;
    return surfel;
}

bool uvsOnScreen(float2 uv){
    return all(uv > float2(0,0)) && all(uv < float2(1,1));
}

// how much a surface depends on the angle
float CalcAngleDepedence(float3 specular, float smoothness){
    return max(specular.r,max(specular.g,specular.b)) * smoothness + 0.1;
}

float CalcAngleDepedence(float specular, float smoothness){
    return specular * smoothness + 0.1;
}

Surfel InitSurfel2(float rawDepth, float3 worldDir, float cameraDirZ, float4 data0, float4 data1, float4 data2){

    Surfel surfel;

    float3 diffuse  = data0.rgb;
    float3 specular = data1.rgb;
    float specular1 = max(specular.r,max(specular.g,specular.b));

    float smoothness = data1.a;
            
    float3 color = diffuse + specular;

    float distance = linearEyeDepth(rawDepth) * cameraDirZ;
    surfel.position.xyz = _CameraPosition + worldDir * distance;

    float3 surfaceDir = normalize(data2.xyz*2.0-1.0);
    surfel.rotation = normalToQuaternion(surfaceDir);
    // surface area of a sphere: 4*pi*r²
    surfel.position.w = calculateSize(distance, dot(surfaceDir, worldDir));
    // surfel.color = float4(uv,frac(depth),1);
    surfel.color = float4(color * START_WEIGHT, START_WEIGHT);
    surfel.colorDx = 0;
    surfel.colorDz = 0;

    surfel.data = float4(
        CalcAngleDepedence(specular1, smoothness),
        specular1, smoothness,
        0 // padding for now
    );

    return surfel;
}

Surfel InitSurfel(float3 worldDir) {
    // default case: sky surfel
    Surfel surfel = InitSkySurfel(worldDir);
    // calculate UV coordinates on camera
    float3 cameraDir = quatRotInv(worldDir, _CameraRotation);
    if(cameraDir.z > 0.0){ // else hidden & no update required
        cameraDir.xy *= _CameraUVScale;
        float2 uv = cameraDir.xy / cameraDir.z * 0.5 + 0.5;
        if(uvsOnScreen(uv)){ // else outside of view frustum
            float rawDepth = _CameraDepthTexture.SampleLevel(_PointClampSampler, uv, 0).r;
            if(rawDepth > 0.0) {
                float4 data0 = _CameraGBufferTexture0.SampleLevel(_PointClampSampler, uv, 0);
                float4 data1 = _CameraGBufferTexture1.SampleLevel(_PointClampSampler, uv, 0);
                float4 data2 = _CameraGBufferTexture2.SampleLevel(_PointClampSampler, uv, 0);
                surfel = InitSurfel2(rawDepth, worldDir, 1.0 / cameraDir.z, data0, data1, data2);
            }
        }
    }
    return surfel;
}

[numthreads(256,1,1)]
void InitSurfelDistribution(uint3 dispatchIdx : SV_DispatchThreadID) {
    uint index = dispatchIdx.x + _DispatchOffset.x;
    uint length = Surfels.Length;
    if(index < length) {
        Surfels[index] = InitSurfel(fibonacciSphere(index, length));
    }
}

SamplerState LinearSampler {
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Wrap;
    AddressV = Wrap;
};

[numthreads(256,1,1)]
void DiscardSmallAndLargeSurfels(uint3 dispatchIdx : SV_DispatchThreadID) {
    uint index = dispatchIdx.x + _DispatchOffset.x;
    uint length1 = Surfels.Length;
    if(index < length1) {
        Surfel surfel = Surfels[index];
        float3 surfelPosition = surfel.position.xyz;
        float3 deltaPos = surfelPosition - _CameraPosition;
        float  distance = length(deltaPos);
        float3 worldDir = deltaPos / distance;
        float3 surfelDir = quatRot(float3(0,1,0), surfel.rotation);
        float targetSize = calculateSize(distance, dot(worldDir, surfelDir));
        float surfelSize = surfel.position.w;
        if(surfelSize > targetSize * 0.707 && surfelSize < targetSize * 1.414) {
            surfel.position.w = targetSize;
            float sizeChangeFactor = min(surfelSize, targetSize) / max(surfelSize, targetSize);
            // if surface is metallic, decrease weight based on angle change and roughness
            float3 oldRelPos = surfelPosition - _PrevCameraPosition;
            float3 newRelPos = surfelPosition - _CameraPosition;
            // could be approximated, since it is an estimate only anyway
            // acos ~ 1-x^5 around x=1
            float angleChange = acos(clamp(dot(newRelPos, oldRelPos) / sqrt(dot(newRelPos,newRelPos) * dot(oldRelPos,oldRelPos)), -1, 1));
            float angleChangeFactor = max(1.0 - 10.0 * angleChange * surfel.data.x, 0.0);
            float factor = sizeChangeFactor * angleChangeFactor;
            
            if(_EnableSurfelMovement){
                // for testing it: move surfel along gradient
                float3 cameraDir = quatRotInv(worldDir, _CameraRotation);
                // else hidden & no update required
                // if the direction is too step, the following algorithm doesn't work well
                if(cameraDir.z > 0.0 /*&& dot(surfelDir, cameraDir) < -0.3*/){ 
                    cameraDir.xy *= _CameraUVScale;
                    uint width = 0, height = 0, mipLevel = 0, numLevels = 0;
                    _Weights.GetDimensions(mipLevel, width, height, numLevels);
                    float2 uv = (cameraDir.xy / cameraDir.z * 0.5 + 0.5) * float2(width-1, height-1);
                    if(uv.x > 0 && uv.x < (int) width-2 && uv.y > 0 && uv.y < (int) height-2){
                        
                        float2 gradient = float2(// to do should use linear interpolation
                            // _Weights.Load(int3(uv.x+1,uv.y,0)).w - _Weights.Load(int3(uv.x-1,uv.y,0)).w,
                            // _Weights.Load(int3(uv.x,uv.y+1,0)).w - _Weights.Load(int3(uv.x,uv.y-1,0)).w
                            _Weights.Load(int3(uv.x+1,uv.y,0)).w - _Weights.Load(int3(uv.x,uv.y,0)).w,
                            _Weights.Load(int3(uv.x,uv.y+1,0)).w - _Weights.Load(int3(uv.x,uv.y,0)).w
                        ) * 10.0;// this factor just sets the maximum speed gradient to 0.1
                        
                        float l2 = dot(gradient,gradient);
                        if(l2 > 1.0) gradient /= sqrt(l2);

                        // move based on distance (and fov maybe)
                        gradient *= surfelSize * 0.02;
                        float3 movement = gradient.x * quatRot(float3(-1,0,0), _CameraRotation) + gradient.y * quatRot(float3(0,-1,0), _CameraRotation);
                        movement -= surfelDir * dot(movement, surfelDir);// prevent surfels from moving away from the surface (if it was a plane)
                        surfel.position.xyz += movement;

                        factor *= max(1.0 - 2.0 * length(movement) / surfelSize, 0.0);
                    }
                }
            }

            surfel.color *= factor;
            surfel.colorDx *= factor;
            surfel.colorDz *= factor;

            Surfels[index] = surfel;
        } else {
            Surfels[index] = InitSurfel(fibonacciSphere(index, length1));
        }
    }
}

// to do if the surfel is off-screen (or behind things), we can "free" the surfel as well
float freeSurfelScore(uint surfelIndex) {
    Surfel surfel = Surfels[surfelIndex];
    float3 worldPos = surfel.position.xyz;
    float3 dir = worldPos - _CameraPosition;
    return /* [0, +Inf], larger is better */ surfel.color.w * 
        /* [-1,0], better alignment is better */ max(1.0 - dot(dir, _CameraDirection), 0.0);
}

void SpawnSurfel(uint3 dispatchIdx, int3 uv, inout uint seed){
    
    // spawn new surfel

    // find free surfel, best by looking through maybe 16 surfels and choosing the one of lowest value to us
	
    uint freeIndex = ((uint) nextRandInt(seed) * 1505776939) % (Surfels.Length - 16);

    uint bestFreeIndex = freeIndex;
    float bestFreeScore = freeSurfelScore(freeIndex);
    freeIndex++;
    for(uint l=freeIndex+15;freeIndex<l;freeIndex++){
            float score = freeSurfelScore(freeIndex);
            if(score > bestFreeScore){
                bestFreeScore = score;
                bestFreeIndex = freeIndex;
            }
        }
        freeIndex = bestFreeIndex;

        // distribute surfel onto pixel

        float3 cameraDir = float3(uv.xy - _CameraOffset.xy, _CameraOffset.z);
	    float3 worldDir = normalize(quatRot(cameraDir, _CameraRotation));

        float rawDepth = _CameraDepthTexture.Load(uv).r;
        if(rawDepth > 0.0) {
            float2 tmpUV = cameraDir.xy/cameraDir.z;
            float cameraDirZ = sqrt(1.0 + dot(tmpUV,tmpUV));
            float4 data0 = _CameraGBufferTexture0.Load(uv);
            float4 data1 = _CameraGBufferTexture1.Load(uv);
            float4 data2 = _CameraGBufferTexture2.Load(uv);
            Surfels[freeIndex] = InitSurfel2(rawDepth, worldDir, cameraDirZ, data0, data1, data2);
        } else if(_AllowSkySurfels) {
            Surfels[freeIndex] = InitSkySurfel(worldDir);
        }
}

[numthreads(16,16,1)]
void SpawnSurfelsInGaps(uint3 dispatchIdx: SV_DispatchThreadID){

    // each thread searches a 16x16 tile for the lowest weight
    // idea from https://media.contentapi.ea.com/content/dam/ea/seed/presentations/cedec2018-towards-effortless-photorealism-through-real-time-raytracing.pdf
    // which seems to be also used in "global illumination based on surfels", Siggraph 2021 EA

    int  tileSizeX = 16;
    int  tileSizeY = 16;
    uint width = 0, height = 0, mipLevel = 0, numLevels = 0;
    _Weights.GetDimensions(mipLevel, width, height, numLevels);
    uint x0 = dispatchIdx.x * tileSizeX, x1 = min(x0 + tileSizeX, width);
    uint y0 = dispatchIdx.y * tileSizeY, y1 = min(y0 + tileSizeX, height);
    // float lowestWeight = 1.0;
    // uint bestX = x0, bestY = y0;
    uint seed = initRand(dispatchIdx.x + (dispatchIdx.y << 16), _FrameIndex);
    for(uint y=y0;y<y1;y++){
        for(uint x=x0;x<x1;x++){
            int3  uvi = int3(x, y, 0);
            float weight = _Weights.Load(uvi).w;
            float depth = _AllowSkySurfels ? 1.0 : _CameraDepthTexture.Load(uvi).r;
            if(depth > 0.0 && weight < 0.01) {
                // lowestWeight = weight;
                // bestX = x;
                // bestY = y;
                SpawnSurfel(dispatchIdx, uvi, seed);
                // to do spawned surfels need to be added into the consideration for next surfels
                return;
            }
        }
    }

    // todo never spawn surfels with a size of less than 1 pixel
    
}