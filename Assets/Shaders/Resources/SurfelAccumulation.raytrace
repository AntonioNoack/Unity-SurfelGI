#include "Common.cginc"

struct Surfel {
    float4 rotation;
    float3 position;
    float size;
    float4 color;
};

float3 _CameraPosition;
float4 _CameraRotation;
float3 _CameraOffset;

int _FrameIndex;

#pragma max_recursion_depth 8

RWStructuredBuffer<Surfel> Surfels;

[shader("raygeneration")]
void RaygenShader() {
	// start one ray per surfel

	// current surfel
	uint index = DispatchRaysIndex().x;
	uint numSurfels, stride;
	Surfels.GetDimensions(numSurfels, stride);
	if(index < numSurfels) {

		// todo only update surfels, which are in front of the camera

		// we know the surface, but we do not know the local BDRF ->
		// we need to trace the first ray, even if we know where it ends

		Surfel surfel = Surfels[index];

		// init random seed from current pixel location and frame index
		uint seed = initRand(index, _FrameIndex);

		// get random uv inside current pixel
		// this gives us anti-aliasing for free
		// + float2(nextRand(seed), nextRand(seed))
		// todo we could spawn random rays to any point of the surfel disk
		float3 deltaPos = surfel.position - _CameraPosition;
		float distance = length(deltaPos);
		float3 rayDir = deltaPos / distance;

		// init ray decriptor
		RayDesc rayDesc;
		rayDesc.Origin = _CameraPosition;
		rayDesc.Direction = rayDir;
		rayDesc.TMin = distance * 0.99;
		rayDesc.TMax = distance * 1.01;

		// Create and init the ray payload
		RayPayload rayPayload;
		rayPayload.color = float3(0.0, 0.0, 0.0);
		rayPayload.randomSeed = seed;
		rayPayload.depth = 0;

		// shoot primary ray
		// flags: https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html
		// maybe for later, for shadows: RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH
		TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_CULL_BACK_FACING_TRIANGLES,
			RAYTRACING_OPAQUE_FLAG, 0, 1, 0, rayDesc, rayPayload);

		surfel.color += float4(rayPayload.color, 1.0);
		Surfels[index] = surfel;

	}
	
}

// "back up" closest hit shader. it is used when we hit material without raytracing shader pass
[shader("closesthit")]
void ClosestHitMain(inout RayPayload rayPayload : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes) {}

// miss shader, used when we don't hit any geometry
TextureCube _SkyBox;
SamplerState _LinearClamp;
[shader("miss")]
void MissShader(inout RayPayload rayPayload : SV_RayPayload) {
	// todo this looks like SDR... how do we get HDR colors?
	float3 color = _SkyBox.SampleLevel(_LinearClamp, WorldRayDirection(), 0).rgb;
	rayPayload.color = rayPayload.depth == 0 ? float3(1,1,1) : color;
}
