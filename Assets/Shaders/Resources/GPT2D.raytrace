
#include "GPT.cginc"

// texture to store raytracing result
RWTexture2D<float4> _DxrTarget;

float3 _CameraOffset;

int _SPP;// todo define
float _Near; // todo define

[shader("raygeneration")]
void PixelGPT() {

    // current pixel
	uint2 dispatchIdx = DispatchRaysIndex().xy;
	// target resolution
	uint2 launchDim = DispatchRaysDimensions().xy;
	
	// init random seed from current pixel location and frame index
	uint seed = initRand(dispatchIdx.x + dispatchIdx.y * launchDim.x, _FrameIndex);

	// get random uv inside current pixel
	// this gives us anti-aliasing for free
	// + float2(nextRand(seed), nextRand(seed))
	float3 rayDir = normalize(quatRot(float3((float2)dispatchIdx - _CameraOffset.xy, _CameraOffset.z), _CameraRotation));

    // _CameraPosition
    // rayDir

    // current surfel
    uint2 index = DispatchRaysIndex().xy;

    // we know the surface, but we do not know the local BDRF .
    // we need to trace the first ray, even if we know where it ends

    float3 surfelPos = _CameraPosition;

    // init ray decriptor
    RayDesc rayDesc;

    // Create and init the ray payload
    RayPayload rayPayload = (RayPayload)0;

    RadianceQueryRecord rRec = (RadianceQueryRecord) 0;
    rRec.its.randomSeed = seed;

    float4 finalColor = 0;
    for (int j = 0; j < _SPP; j++) {

        rRec.type = ERadiance;

        RayState mainRay = (RayState) 0;
        // define first ray
        mainRay.ray.o = _CameraPosition;
        mainRay.ray.d = rayDir;
        // mint and maxt can be pretty exact, because we set the surfel exactly on the surface
        mainRay.ray.mint = _Near;
        mainRay.ray.maxt = _Far;
        mainRay.throughput = float3(1,1,1);
        mainRay.pdf = 1.0;
		mainRay.rRec = rRec;
		mainRay.rRec.its = rRec.its;

        RayState shiftedRays[4];

        shiftedRays[0].ray.d.xy = float2(+1.0,  0.0);
        shiftedRays[1].ray.d.xy = float2( 0.0, +1.0);
        shiftedRays[2].ray.d.xy = float2(-1.0,  0.0);
        shiftedRays[3].ray.d.xy = float2( 0.0, -1.0);
        
        for(int i = 0; i < 4; i++) {
            // define first ray for gradients
            shiftedRays[i].ray.o = _CameraPosition;
	        float3 rayDir1 = normalize(quatRot(float3(
                (float2)dispatchIdx + shiftedRays[i].ray.d.xy - _CameraOffset.xy,
                _CameraOffset.z
            ), _CameraRotation));
            shiftedRays[i].ray.d = rayDir1;
            shiftedRays[i].ray.mint = _Near;
            shiftedRays[i].ray.maxt = _Far;
			shiftedRays[i].throughput = float3(1,1,1);
			shiftedRays[i].rRec = rRec;
		}

        float3 veryDirect = 0;
        bool ok = evaluate(mainRay, shiftedRays, 4, veryDirect);
        if(!ok) continue;

        // update surfel by main and shiftedRays
        // to do divide by color of first hit...
        // what is the weight? where is it coming from? looks like it's always just 1 (normalized)
        // why was the pdf for nearly all rays 0.0? because we needed to set mainRay.pdf beforehand
        float weight = mainRay.pdf;
        float3 color = mainRay.radiance + veryDirect;
        if(all(color >= 0.0) && weight >= 0) {
            finalColor += float4(color, weight); // is it correct to add veryDirect here?
        }
        /*float3 gradient1 = 0.5 * (shiftedRays[0].gradient - shiftedRays[2].gradient) / distance;
        float3 gradient2 = 0.5 * (shiftedRays[1].gradient - shiftedRays[3].gradient) / distance;
		float3 gradientDX = gradient1 * cosa + gradient2 * sina;
		float3 gradientDZ =-gradient1 * sina + gradient2 * cosa;
        surfel.colorDx += float4(gradientDX, weight);
        surfel.colorDz += float4(gradientDZ, weight);*/

    }

	// store result
	_DxrTarget[index] = finalColor;

}
