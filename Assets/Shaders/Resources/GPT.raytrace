
#include "GPT.cginc"

RWStructuredBuffer<Surfel> _Surfels;
int _SPP;

[shader("raygeneration")]
void SurfelGPT() {

    // start one ray per surfel

    // current surfel
    uint index = DispatchRaysIndex().x;
    uint numSurfels,
    stride;
    _Surfels.GetDimensions(numSurfels, stride);
    if (index >= numSurfels)
        return;

    // we know the surface, but we do not know the local BDRF .
    // we need to trace the first ray, even if we know where it ends

    Surfel surfel = _Surfels[index];
    float surfelSize = surfel.position.w;
    if (surfelSize >= _Far * 0.5)
        return; // the sky has GI = 1, so no updates required

    float3 surfelPos = surfel.position.xyz;
    float4 surfelRotation = surfel.rotation;
    float3 worldDir = normalize(surfelPos - _CameraPosition);
    float3 worldNormal = quatRot(float3(0, 1, 0), surfel.rotation);
    float3 cameraDir = quatRotInv(worldDir, _CameraRotation);

    // only update surfels, which are in front of the camera
    float2 uvTolerance = 1.05; // close to edge should be traced as well
    if (!(cameraDir.z > 0.0 && all(abs(cameraDir.xy) < _CameraUVSize * uvTolerance) &&
            // test whether the surfel can be visible from the camera; the sky has no GBuffer information in Unity . skip this test
            dot(worldDir, worldNormal) < 0.0))
        return;

    // init random seed from current pixel location and frame index
    uint seed = initRand(index, _FrameIndex);

    //max(1, 8 - (int) surfel.color.w);
    int samplesPerSurfel = _SPP; 

    // Create and init the ray payload
    RayPayload rayPayload = (RayPayload)0;
    rayPayload.surfelRotation = surfel.rotation;
    rayPayload.surfelSize = surfelSize;

    float cosa;
    float sina;
    float distance;
    float3 ray1Pos;
    float3 ray2Pos;

    GenerateGradientRays(
        surfelPos, surfelRotation, surfelSize, rayPayload.randomSeed,
        cosa, sina, distance, ray1Pos, ray2Pos);

    bool hasChanged = false;

    RadianceQueryRecord rRec = (RadianceQueryRecord) 0;
    rRec.its.randomSeed = seed;

    for (int j = 0; j < samplesPerSurfel; j++) {

        // go back a step
        float startDist = 0.1 * surfelSize;
        float3 origin = surfelPos - startDist * worldDir;
        float3 delta = surfelPos - _CameraPosition;

        rRec.type = ERadiance;

        RayState mainRay = (RayState) 0;
        // define first ray
        mainRay.ray.o = origin;
        mainRay.ray.d = normalize(delta);
        // mint and maxt can be pretty exact, because we set the surfel exactly on the surface
        mainRay.ray.mint = startDist * 0.9;
        mainRay.ray.maxt = startDist * 1.1;
        mainRay.throughput = float3(1,1,1);
        mainRay.pdf = 1.0;
		mainRay.rRec = rRec;
		mainRay.rRec.its = rRec.its;

        RayState shiftedRays[4];

        shiftedRays[0].ray.o = ray1Pos;
        shiftedRays[1].ray.o = ray2Pos;
        shiftedRays[2].ray.o = surfelPos * 2 - ray1Pos;
        shiftedRays[3].ray.o = surfelPos * 2 - ray2Pos;
        
        for(int i = 0; i < 4; i++) {
            // define first ray for gradients
            float startDist1 = 0.5 * surfelSize;
            float3 surfelPos1 = shiftedRays[i].ray.o;
            float3 origin1 = surfelPos1 - startDist1 * worldDir;
            float3 delta1  = surfelPos1 - _CameraPosition;
            shiftedRays[i].ray.o = origin1;
            shiftedRays[i].ray.d = normalize(delta1);
            // mint and maxt must account for a possible non-planar surface
            shiftedRays[i].ray.mint = startDist1 * 0.5;
            shiftedRays[i].ray.maxt = startDist1 * 2.0;
			shiftedRays[i].throughput = float3(1,1,1);
			shiftedRays[i].rRec = rRec;
		}

        float3 veryDirect = 0;
        bool ok = evaluate(mainRay, shiftedRays, 4, veryDirect);
        if(!ok) continue;

        // update surfel by main and shiftedRays
        // todo divide by color of first hit...
        // what is the weight? where is it coming from? looks like it's always just 1 (normalized)
        // why was the pdf for nearly all rays 0.0? because we needed to set mainRay.pdf beforehand
        float weight = mainRay.pdf;
        float3 color = mainRay.radiance + veryDirect;
        // todo how can weight or color be negative???
        // if(all(color >= 0.0) && weight >= 0) 
            surfel.color += float4(color, weight); // is it correct to add veryDirect here?
        float3 gradient1 = 0.5 * (shiftedRays[0].gradient - shiftedRays[2].gradient) / distance;
        float3 gradient2 = 0.5 * (shiftedRays[1].gradient - shiftedRays[3].gradient) / distance;
		float3 gradientDX = gradient1 * cosa + gradient2 * sina;
		float3 gradientDZ =-gradient1 * sina + gradient2 * cosa;
        surfel.colorDx += float4(gradientDX, weight);
        surfel.colorDz += float4(gradientDZ, weight);

        hasChanged = true;

    }
    if (hasChanged) {
        _Surfels[index] = surfel;
    }
}

// texture to store raytracing result
RWTexture2D<float4> _ColorTarget;
RWTexture2D<float4> _ColorDxTarget;
RWTexture2D<float4> _ColorDyTarget;

float3 _CameraOffset;

float _Near;

[shader("raygeneration")]
void PixelGPT() {

    // current pixel
	uint2 dispatchIdx = DispatchRaysIndex().xy;
	// target resolution
	uint2 launchDim = DispatchRaysDimensions().xy;
	
	// init random seed from current pixel location and frame index
	uint seed = initRand(dispatchIdx.x + dispatchIdx.y * launchDim.x, _FrameIndex);

	// get random uv inside current pixel
	// this gives us anti-aliasing for free
	// + float2(nextRand(seed), nextRand(seed))
	float3 rayDir = normalize(quatRot(float3((float2)dispatchIdx - _CameraOffset.xy, _CameraOffset.z), _CameraRotation));

    // _CameraPosition
    // rayDir

    // current surfel
    uint2 index = DispatchRaysIndex().xy;

    // we know the surface, but we do not know the local BDRF .
    // we need to trace the first ray, even if we know where it ends

    float3 surfelPos = _CameraPosition;

    RadianceQueryRecord rRec = (RadianceQueryRecord) 0;
    rRec.its.randomSeed = seed;

    float4 finalColor = float4(0,0,0,0.0001);
    for (int j = 0; j < _SPP; j++) {

        rRec.type = ERadiance;

        RayState mainRay = (RayState) 0;
        // define first ray
        mainRay.ray.o = _CameraPosition;
        mainRay.ray.d = rayDir;
        // mint and maxt can be pretty exact, because we set the surfel exactly on the surface
        mainRay.ray.mint = _Near;
        mainRay.ray.maxt = _Far;
        mainRay.throughput = float3(1,1,1);
        mainRay.pdf = 1.0;
		mainRay.rRec = rRec;
		mainRay.rRec.its = rRec.its;

        RayState shiftedRays[4];

        shiftedRays[0].ray.d.xy = float2(+1.0,  0.0);
        shiftedRays[1].ray.d.xy = float2( 0.0, +1.0);
        shiftedRays[2].ray.d.xy = float2(-1.0,  0.0);
        shiftedRays[3].ray.d.xy = float2( 0.0, -1.0);
        
        for(int i = 0; i < 4; i++) {
            // define first ray for gradients
            shiftedRays[i].ray.o = _CameraPosition;
	        float3 rayDir1 = normalize(quatRot(float3(
                (float2)dispatchIdx + shiftedRays[i].ray.d.xy - _CameraOffset.xy,
                _CameraOffset.z
            ), _CameraRotation));
            shiftedRays[i].ray.d = rayDir1;
            shiftedRays[i].ray.mint = _Near;
            shiftedRays[i].ray.maxt = _Far;
			shiftedRays[i].throughput = float3(1,1,1);
			shiftedRays[i].rRec = rRec;
		}

        float3 veryDirect = 0;
        bool ok = evaluate(mainRay, shiftedRays, 4, veryDirect);
        if(!ok) continue;

        // update surfel by main and shiftedRays
        // to do divide by color of first hit...
        // what is the weight? where is it coming from? looks like it's always just 1 (normalized)
        // why was the pdf for nearly all rays 0.0? because we needed to set mainRay.pdf beforehand
        float weight = mainRay.pdf;
        float3 color = mainRay.radiance + veryDirect;
        if(all(color >= 0.0) && weight >= 0) // this should be always true; but it isn't; so it filters NaNs
            finalColor += float4(color, weight); // is it correct to add veryDirect here?
        
        /*float3 gradient1 = 0.5 * (shiftedRays[0].gradient - shiftedRays[2].gradient) / distance;
        float3 gradient2 = 0.5 * (shiftedRays[1].gradient - shiftedRays[3].gradient) / distance;
		float3 gradientDX = gradient1 * cosa + gradient2 * sina;
		float3 gradientDZ =-gradient1 * sina + gradient2 * cosa;
        surfel.colorDx += float4(gradientDX, weight);
        surfel.colorDz += float4(gradientDZ, weight);*/

    }

	// store result
	_ColorTarget[index] = finalColor;

}
